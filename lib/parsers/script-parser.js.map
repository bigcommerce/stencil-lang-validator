{"version":3,"sources":["../../src/lib/parsers/script-parser.js"],"names":["parseScript","isMethod","getExpressionValue","eachNode","babylon","scriptFile","parse","sourceType","plugins","node","calleeName","methodName","callee","object","property","arguments","length","type","name","expression","value","operator","left","right","callback","ast","content","stepInto","error","innerNode"],"mappings":";;;;;;;;;;QAQgBA,W,GAAAA,W;QAqBAC,Q,GAAAA,Q;QAyBAC,kB,GAAAA,kB;QAqBAC,Q,GAAAA,Q;;AA3EhB;;IAAYC,O;;AACZ;;;;;;AAEA;;;;;AAKO,SAASJ,WAAT,CAAqBK,UAArB,EAAiC;AACpC,WAAOD,QAAQE,KAAR,CAAcD,UAAd,EAA0B;AAC7BE,oBAAY,QADiB;AAE7BC,iBAAS,CACL,KADK,EAEL,kBAFK,EAGL,YAHK,EAIL,iBAJK,EAKL,kBALK,EAML,cANK;AAFoB,KAA1B,CAAP;AAWH;;AAED;;;;;;;AAOO,SAASP,QAAT,CAAkBQ,IAAlB,EAAwBC,UAAxB,EAAoCC,UAApC,EAAgD;AACnD,QAAI,CAACF,IAAD,IAAS,CAACA,KAAKG,MAAf,IAAyB,CAACH,KAAKG,MAAL,CAAYC,MAAtC,IAAgD,CAACJ,KAAKG,MAAL,CAAYE,QAA7D,IAAyE,CAACL,KAAKM,SAA/E,IAA4F,CAACN,KAAKM,SAAL,CAAeC,MAAhH,EAAwH;AACpH,eAAO,KAAP;AACH;;AAED,QAAIP,KAAKQ,IAAL,KAAc,gBAAd,IAAkCR,KAAKG,MAAL,CAAYK,IAAZ,KAAqB,kBAA3D,EAA+E;AAC3E,eAAO,KAAP;AACH;;AAED,QAAIR,KAAKG,MAAL,CAAYE,QAAZ,CAAqBI,IAArB,KAA8BP,UAAlC,EAA8C;AAC1C,eAAO,KAAP;AACH;;AAED,QAAIF,KAAKG,MAAL,CAAYC,MAAZ,CAAmBK,IAAnB,KAA4BR,UAA5B,IAA2CD,KAAKG,MAAL,CAAYC,MAAZ,CAAmBC,QAAnB,IAA+BL,KAAKG,MAAL,CAAYC,MAAZ,CAAmBC,QAAnB,CAA4BI,IAA5B,KAAqCR,UAAnH,EAAgI;AAC5H,eAAO,KAAP;AACH;;AAED,WAAO,IAAP;AACH;;AAED;;;;;AAKO,SAASR,kBAAT,CAA4BO,IAA5B,EAAkC;AACrC,QAAIU,aAAa,EAAjB;;AAEA,QAAIV,KAAKQ,IAAL,KAAc,eAAlB,EAAmC;AAC/BE,qBAAaV,KAAKW,KAAlB;AACH;;AAED,QAAIX,KAAKQ,IAAL,KAAc,kBAAd,IAAoCR,KAAKY,QAAL,KAAkB,GAA1D,EAA+D;AAC3DF,sBAAcjB,mBAAmBO,KAAKa,IAAxB,CAAd;AACAH,sBAAcjB,mBAAmBO,KAAKc,KAAxB,CAAd;AACH;;AAED,WAAOJ,UAAP;AACH;;AAED;;;;;;AAMO,SAAShB,QAAT,CAAkBE,UAAlB,EAA8BmB,QAA9B,EAAwC;AAC3C,QAAI;AACA,YAAMC,MAAMzB,YAAYK,WAAWqB,OAAvB,CAAZ;;AAEAC,iBAASF,GAAT,EAAc;AAAA,mBAAQD,SAAS,IAAT,EAAef,IAAf,CAAR;AAAA,SAAd;AACH,KAJD,CAIE,OAAOmB,KAAP,EAAc;AACZJ,iBAASI,KAAT;AACH;AACJ;;AAED;;;;;;;AAOA,SAASD,QAAT,CAAkBlB,IAAlB,EAAwBe,QAAxB,EAAkC;AAC9BA,aAASf,IAAT;;AAEA,sBAAKA,IAAL,EAAW,UAACoB,SAAD,EAAe;AACtB,YAAI,QAAOA,SAAP,uDAAOA,SAAP,OAAqB,QAAzB,EAAmC;AAC/BF,qBAASE,SAAT,EAAoBL,QAApB;AACH;AACJ,KAJD;AAKH","file":"script-parser.js","sourcesContent":["import * as babylon from 'babylon';\nimport { each } from 'lodash';\n\n/**\n * Parse a script file and return AST\n * @param {string} scriptFile\n * @return {Object}\n */\nexport function parseScript(scriptFile) {\n    return babylon.parse(scriptFile, {\n        sourceType: 'module',\n        plugins: [\n            'jsx',\n            'objectRestSpread',\n            'decorators',\n            'classProperties',\n            'exportExtensions',\n            'functionBind',\n        ],\n    });\n}\n\n/**\n * Check if a node is a method\n * @param {Object} node\n * @param {string} calleeName\n * @param {string} methodName\n * @return {boolean}\n */\nexport function isMethod(node, calleeName, methodName) {\n    if (!node || !node.callee || !node.callee.object || !node.callee.property || !node.arguments || !node.arguments.length) {\n        return false;\n    }\n\n    if (node.type !== 'CallExpression' || node.callee.type !== 'MemberExpression') {\n        return false;\n    }\n\n    if (node.callee.property.name !== methodName) {\n        return false;\n    }\n\n    if (node.callee.object.name !== calleeName && (node.callee.object.property && node.callee.object.property.name !== calleeName)) {\n        return false;\n    }\n\n    return true;\n}\n\n/**\n * Get the value of an expression node\n * @param {Object} node\n * @return {string}\n */\nexport function getExpressionValue(node) {\n    let expression = '';\n\n    if (node.type === 'StringLiteral') {\n        expression = node.value;\n    }\n\n    if (node.type === 'BinaryExpression' && node.operator === '+') {\n        expression += getExpressionValue(node.left);\n        expression += getExpressionValue(node.right);\n    }\n\n    return expression;\n}\n\n/**\n * Iterate over each AST node\n * @param {Object} scriptFile\n * @param {Function} callback\n * @return {void}\n */\nexport function eachNode(scriptFile, callback) {\n    try {\n        const ast = parseScript(scriptFile.content);\n\n        stepInto(ast, node => callback(null, node));\n    } catch (error) {\n        callback(error);\n    }\n}\n\n/**\n * Step into AST node\n * @private\n * @param {Object} node\n * @param {Function} callback\n * @return {void}\n */\nfunction stepInto(node, callback) {\n    callback(node);\n\n    each(node, (innerNode) => {\n        if (typeof innerNode === 'object') {\n            stepInto(innerNode, callback);\n        }\n    });\n}\n"]}